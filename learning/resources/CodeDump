    dec evaluateCluster(Clustering cluster, Cluster clusters[]) {
        if (previousClusters == null) {
            return 0.0
        }
        //take the distance between the means for each cluster 
        int fullMesh = (k*(k-1))/2
        //dont do it this way plz
        int prevClusterCount = previousClusters.arrayLength
        //not working dec pow = power(numberOfPrevClusters, 2.0)
        dec prevDistances[] = new dec[prevClusterCount*prevClusterCount]
        dec currDistances[] = new dec[clusters.arrayLength*clusters.arrayLength]
        for (int i = 0; i < k; i++) {
            for (int j = 0; j < k; j++) {
                if (i == j) {}
                else {
                    //zero index just for now
                    currDistances[(i*k)+j] = positive(clusters[i].mean[0] - clusters[j].mean[0])
                }
            }
        }
        for (int i = 0; i < prevClusterCount; i++) {
            for (int j = 0; j < prevClusterCount; j++) {
                if (i == j) {}
                else {
                    //zero index just for now
                    prevDistances[(i*prevClusterCount)+j]= positive(previousClusters[i].mean[0] - previousClusters[j].mean[0])
                }
            }
        }
        //take an average of these distances (number of clusters may change so avg is needed)
        dec currentAvg 
        for (int i = 0; i < currDistances.arrayLength) {
            currentAvg+=currDistances[i]
        }
        currentAvg = currentAvg/currDistances.arrayLength

        dec prevAvg
        for (int i = 0; i < prevDistances.arrayLength) {
            prevAvg+=prevDistances[i]
        }
        prevAvg = prevAvg/prevDistances.arrayLength

        //which cluster has the larger average distance?
        //reward the clusters that are more discrete
        dec reward
        if (currentAvg > prevAvg) {
            //reward pos
            reward = 1.0
        }
        else if (currentAvg == prevAvg) {
            //neutral reward
            reward = 0.5
        }
        else {
            //neg reward
            reward = 0.0
        }
        return reward
    }

        else if (action == 2) {
            //reduceRange()
            //get furthest point from the mean
            dec mean[] = cluster.cluster(k)[currentEnv].mean 
            Cluster envCluster = cluster.cluster(k)[currentEnv]

            dec furthestPoint[] = new dec[dimentions]
            dec topScore = 0
            dec currentPointScore = 0

            //for each point in cluster, take the sum of the differences
            //of the distances in each dimention between itself and the mean
            //if a new greatest sum is found, save that point as the furthest point

            for (int j = 0; j < envCluster.members.arrayLength; j++) {
                dec currentPoint[] = envCluster.members[j].values
                for (int i = 0; i < dimentions; i++) {
                    currentPointScore += positive(currentPoint[i] - mean[i])
                }
                if (currentPointScore > topScore) {
                    topScore = currentPointScore
                    furthestPoint = currentPoint
                }
            }

            //remove that point from the clustering object
            cluster.rmValue(furthestPoint)
        }
        else if (action == 3) {
            //increaseRange()
            //get the furthest value from the mean for each dimention
            dec mean[] = cluster.cluster(k)[currentEnv].mean 
            Cluster envCluster = cluster.cluster(k)[currentEnv]

            dec furthestInEachDi[] = new dec[dimentions]
            for (int i = 0; i < dimentions; i ++) {
                furthestInEachDi[i] = 0
            }
            
            for (int i = 0; i < envCluster.members.arrayLength; i++) {
                dec currentPoint[] = envCluster.members[i].values
                for (int j = 0; j < dimentions; j++) {
                    dec delta = positive(currentPoint[j]-mean[j])
                    if (delta > furthestInEachDi[j]) {
                        furthestInEachDi[j] = delta
                    }
                }
            }
            
            //generate random number in range
            Random generator = new Random()
            generator.setSeed(123456)
            dec synthPoint[] = new dec[dimentions]
            for (int i = 0; i < dimentions; i++) {
                synthPoint[i] = mean[i] + furthestInEachDi[i] + generator.getDec(0.0, 5.0)
            }
            //add data point to clustering object
            cluster.addValue(synthPoint, null)
        }
        else if (action == 4) {
            //do nothing
        }
